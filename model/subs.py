""" database dependencies to support sqliteDB examples """
from random import randrange
from datetime import date
import os, base64
import json

from __init__ import app, db
from sqlalchemy.exc import IntegrityError
from werkzeug.security import generate_password_hash, check_password_hash

class Post(db.Model):
    __tablename__ = 'posts'

    id = db.Column(db.Integer, primary_key=True)
    subID = db.Column(db.Integer, db.ForeignKey('subs.id'))

    def __init__(self, id):
        self.subID = id

    def __repr__(self):
        return "Notes(" + str(self.id) + "," + self.note + "," + str(self.subID) + ")"

    def create(self):
        try:
            db.session.add(self)
            db.session.commit() 
            return self
        except IntegrityError:
            db.session.remove()
            return None

    def read(self):
        # encode image
        path = app.config['UPLOAD_FOLDER']
        file = os.path.join(path, self.image)
        file_text = open(file, 'rb')
        file_read = file_text.read()
        file_encode = base64.encodebytes(file_read)
        
        return {
            "id": self.id,
            "subID": self.subID,
            "base64": str(file_encode)
        }

class User(db.Model):
    __tablename__ = 'users'  # table name is plural, class name is singular

    id = db.Column(db.Integer, primary_key=True)
    _sbs = db.Column(db.String(255), unique=True, nullable=False)

    posts = db.relationship("Post", cascade='all, delete', backref='users', lazy=True)

    def __init__(self, sbs):

        self._uid = sbs

    @property
    def uid(self):
        return self._sbs
    

    @uid.setter
    def sbs(self, sbs):
        self._uid = sbs
        
    def is_uid(self, sbs):
        return self._sbs == sbs

    def __str__(self):
        return json.dumps(self.read())

    def create(self):
        try:
            db.session.add(self)
            db.session.commit()
            return self
        except IntegrityError:
            db.session.remove()
            return None


    def read(self):
        return {
            "id": self.id,
            "sbs": self.sbs,
        }

    def update(self, sbs=""):
        """only updates values with length"""
        if len(sbs) > 0:
            self.sbs = sbs
        db.session.commit()
        return self

    def delete(self):
        db.session.delete(self)
        db.session.commit()
        return None

def initSubs():
    db.create_all()
    """Tester data"""
    s1 = subs(sbs='A.B')
    s2 = subs(sbs='C.D')
    s3 = subs(sbs='E.F')
    s4 = subs(sbs='G.H')
    s5 = subs(sbs='I.J')

    subs = [s1, s2, s3, s4, s5]

    """Builds sample user/note(s) data"""
    for subs in subs:
        try:
            '''add a few 1 to 4 notes per user'''
            for num in range(randrange(1, 4)):
                note = "#### " + subs.name + " note " + str(num) + ". \n Generated by test data."
                subs.posts.append(Post(id=subs.id, note=note, image='ncs_logo.png'))
            '''add user/post data to table'''
            subs.create()
        except IntegrityError:
            '''fails with bad or duplicate data'''
            db.session.remove()
            print(f"Records exist, duplicate email, or error: {subs.uid}")
            